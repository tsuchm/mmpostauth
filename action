#!/usr/bin/perl

use CGI qw/ header /;
use CGI::Carp qw/ fatalsToBrowser /;
use CGI::Fast;
use CGI::Session qw/ -ip-match /;
use Config::Simple qw/ -lc /;
use Cwd qw/ abs_path /;
use Encode qw/ encode_utf8 decode_utf8 decode /;
use English qw/ $PROGRAM_NAME /;
use File::Find qw/ find /;
use File::Basename qw/ basename dirname /;
use File::Spec::Functions qw/ catfile /;
use File::stat;
use File::Temp qw/ tempfile tempdir /;
use HTML::Template;
use JSON qw/ decode_json /;
use LWP::UserAgent;
use MIME::Parser;
use MIME::Entity;
use MIME::Words qw/ decode_mimewords /;
use strict;
use utf8;
use feature qw/ state /;
use open qw/ :utf8 :std /;
use constant CONFIGFILE => 'mmpostauth.ini';
use constant GOOGLEURL => 'https://www.google.com/recaptcha/api/siteverify';

our $CONFIG;

my $mtime = stat($PROGRAM_NAME)->mtime;
while( my $cgi = CGI::Fast->new ){
    exit if stat($PROGRAM_NAME)->mtime > $mtime;
    &read_config();
    my $session = CGI::Session->new( 'driver:db_file;serializer:Storable',
				     $cgi,
				     { FileName => &catfile( &param_spooldir(), 'session.db' ) } );
    $session->expire( '+30m' );
    &main( $cgi, $session );
}

sub main {
    my( $cgi, $session ) = @_;
    if( $cgi->path_info =~ m!/status\Z! ){
	print &header( -status => 200, -type => 'text/plain' ), "OK";
    } elsif( $cgi->path_info =~ m!/post\Z! ){
	&post( $cgi );
    } elsif( my( $action, $qid ) = ( $cgi->path_info =~ m!/(login|confirm|approve|revoke)/([a-zA-Z0-9_]{12})\Z! ) ){
	no strict 'refs';
	&{$action}( $cgi, $session, $qid );
    } else {
	print &header( -status => 404, -type => 'text/plain' ), "No valid action.";
    }
}

sub post {
    my( $cgi ) = @_;
    my $fh = $cgi->upload('message');
    unless( $fh ){
	print &header( -status => 400, -type => 'text/plain' ), "No message is given.\n";
	return;
    }
    my $parser = MIME::Parser->new();
    $parser->output_under( &tempdir( CLEANUP => 1 ) );
    my $message = $parser->parse( $fh->handle() );
    my( $listname, $target, $confirm ) = &parse_message( $message );
    unless( $listname ){
	print &header( -status => 415, -type => 'text/plain' ), "Invalid mailman moderation message.\n";
	return;
    }
    unless( my $password = &param_password($listname) ){
	print &header( -status => 403, -type => 'text/plain' );
	printf "No password is specified for `%s'.  Edit `%s' at `%s'.\n", $listname, CONFIGFILE, $cgi->url;
	return;
    }

    my( $qfh, $qid ) = eval { &tempfile( 'XXXXXXXXXXXX', DIR => &param_spooldir(), UNLINK => 0 ); };
    unless( $qfh and $qid ){
	print &header( -status => 507, -type => 'text/plain' ), "Cannot create a spool file.\n";
	return;
    }
    print $qfh $message->as_string;
    close $qfh;

    if( my $pat = &param_notifypat($listname) ){
	my $from = &extract_address( $target->head->get('From') );
	unless( $from =~ m/$pat/ ){
	    print &header( -status => 204, -type => 'text/plain' );
	    return;
	}
    }

    my $listto = &extract_address( ( $target->head->get('delivered-to') )[-1] );
    my $template = &open_template( filename => 'notify.tmpl', die_on_bad_params => 0 );
    $template->param( listto => $listto,
		      baseurl => $cgi->url,
		      qid => &basename($qid) );

    my $notify = MIME::Entity->build( From => &extract_address($message->head->get('from')),
				      To => &extract_address($target->head->get('return-path') || $target->head->get('from')),
				      Subject => 'Your message requires the additional confirmation step',
				      Type => 'text/plain; charset=utf-8',
				      Encoding => 'base64',
				      Data => &encode_utf8($template->output) );
    if( my $bcc = &param_notifybcc($listname) ){
	$notify->head->set( 'Bcc', $bcc );
    }
    if( &param_debug() ){
	$notify->print_header( \*STDERR );
	print "\n", $template->output;
    } else {
	unless( $notify->smtpsend( Host => &param_smtpserver() ) ){
	    print &header( -status => 503, -type => 'text/plain' ), "Failed to send the notify message.\n";
	    return;
	}
    }
    print &header( -status => 200, -type => 'text/plain', -charset => 'UTF-8' );
    $notify->print_header( \*STDOUT );
    print "\n", $template->output;
    &expire_spool();
}

sub expire_spool {
    if( my $expire = &param_expire() ){
	my $dir = &param_spooldir();
	if( opendir( my $dh, $dir ) ){
	    while( my $x = readdir( $dh ) ){
		next unless $x =~ m/\A[a-zA-Z0-9_]{12}\Z/;
		&revoke( $x ) if ( stat( &catfile( $dir, $x ) )->mtime + $expire ) < time;
	    }
	}
    }
}

sub login {
    my( $cgi, $session, $qid ) = @_;
    if( $ENV{REMOTE_USER} ){
	$session->param( uid => $ENV{REMOTE_USER} );
	&redirect_confirm( $cgi, $session, $qid );
    } else {
	$session->param( uid => undef );
	my $template = &open_template( filename => 'forbidden.tmpl', die_on_bad_params => 0 );
	$template->param( qid => $qid );
	print &header( -status => 403, -type => 'text/html' ), $template->output;
    }
}

sub confirm {
    my( $cgi, $session, $qid ) = @_;
    my $message = &read_message( $qid );
    my( $listname, $target, $confirm ) = &parse_message( $message );
    unless( $listname ){
	&expire_page( $qid );
	return;
    }
    if( &param_login($listname) and ! $session->param('uid') ){
	&redirect_login( $cgi, $session, $qid );
	return;
    }
    my $template = &open_template( filename => 'confirm.tmpl', die_on_bad_params => 0 );
    $template->param( listto => &extract_address( ( $target->head->get('delivered-to') )[-1] ),
		      from => &decode_header( $target->head->get('From') ),
		      to => &decode_header( $target->head->get('To') ),
		      subject => &decode_header( $target->head->get('Subject') ),
		      date => $target->head->get('Date'),
		      messageid => $target->head->get('Message-ID'),
		      qid => $qid );
    $template->param( sitekey => &param_sitekey($listname) );
    print( &header( -type => 'text/html',
		    -charset => 'UTF-8',
		    -cookie => &cookie_string( $cgi, $session ) ),
	   $template->output );
    $session->param( qid => $qid );
}

sub approve {
    my( $cgi, $session, $qid, $revoke ) = @_;
    unless( $session->param('qid') eq $qid ){
	&redirect_confirm( $cgi, $session, $qid );
	$session->param( qid => undef );
	return;
    }
    my $message = &read_message( $qid );
    my( $listname, $target, $confirm ) = &parse_message( $message );
    unless( $listname ){
	&expire_page( $qid );
	return;
    }
    if( &param_login($listname) and ! $session->param('uid') ){
	&redirect_login( $cgi, $session, $qid );
	return;
    }
    unless( $revoke or &check_captcha( $cgi, $listname ) ){
	&redirect_confirm( $cgi, $session, $qid );
	return;
    }
    my $command = MIME::Entity->build( From     => &extract_address( ( $message->head->get('delivered-to') )[0] ),
				       To       => $confirm->head->get('from'),
				       Subject  => $confirm->head->get('subject'),
				       Type     => 'text/plain',
				       Encoding => '7bit',
				       Data     => [ '' ] );
    unless( $revoke ){
	# When no 'Approved: <password>' header is set, this command
	# message will be regarded as a revoke command.
	if( my $password = &param_password($listname) ){
	    $command->head->set( 'approved', $password );
	} else {
	    die sprintf( "No password is specified for `%s'.  Edit `%s'", $listname, CONFIGFILE);
	}
    }
    if( &param_debug() ){
	$command->print( \*STDERR );
    } else {
	unless( $command->smtpsend( Host => &param_smtpserver() ) ){
	    print( &header( -status => 503, -type => 'text/plain' ),
		   'Failed to send the command message to the mailing list server.' );
	    return;
	}
    }
    unless( unlink( &catfile( &param_spooldir(), $qid ) ) ){
	print( &header( -status => 503, -type => 'text/plain' ),
	       'Failed to remove temporary file.' );
	return;
    }
    my $template = &open_template( filename => ( $revoke ? 'revoke.tmpl' : 'approve.tmpl' ),
				   die_on_bad_params => 0 );
    $template->param( listto => &extract_address( ( $target->head->get('delivered-to') )[-1] ),
		      from => &decode_header( $target->head->get('From') ),
		      to => &decode_header( $target->head->get('To') ),
		      subject => &decode_header( $target->head->get('Subject') ),
		      date => $target->head->get('Date'),
		      messageid => $target->head->get('Message-ID') );
    print( &header( -type => 'text/html',
		    -charset => 'UTF-8',
		    -cookie => &cookie_string( $cgi, $session ) ),
	   $template->output );
}

sub revoke {
    my( $cgi, $session, $qid ) = @_;
    &approve( $cgi, $session, $qid, 1 );
}

sub redirect_confirm {
    my( $cgi, $session, $qid ) = @_;
    print &header( -status => 302,
		   -location => sprintf( '%s/confirm/%s', $cgi->url, $qid ),
		   -cookie => &cookie_string( $cgi, $session ) );
}

sub redirect_login {
    my( $cgi, $session, $qid ) = @_;
    print &header( -status => 302,
		   -location => sprintf( '%s/login/%s', $cgi->url, $qid ),
		   -cookie => &cookie_string( $cgi, $session ) );
}

sub cookie_string {
    my( $cgi, $session ) = @_;
    $cgi->cookie( -name => $session->name,
		  -value => $session->id,
		  -domain => $cgi->server_name,
		  -path => $cgi->script_name );
}

sub expire_page {
    my( $qid ) = @_;
    my $template = &open_template( filename => 'expire.tmpl', die_on_bad_params => 0 );
    $template->param( qid => $qid );
    print &header( -status => 404, -type => 'text/html', -charset => 'UTF-8' ), $template->output;
}

sub read_message {
    my( $qid ) = @_;
    my $filename = &catfile( &param_spooldir(), $qid );
    if( open( my $fh, '<:bytes', $filename ) ){
	my $parser = MIME::Parser->new();
	$parser->output_under( &tempdir( CLEANUP => 1 ) );
	$parser->parse( $fh );
    } else {
	warn sprintf( 'Cannot read %s: %s', $filename, $! ) if -f $filename;
	undef;
    }
}

sub parse_message {
    my( $message ) = @_;
    return wantarray ? () : 0 unless $message;

    # Try to extract the mailing list name from the mailman moderation
    # message.  If no mailing list name is found, this message is
    # invalid.
    my $listname = $message->head->get('x-beenthere');
    $listname =~ s/\A\s+//;
    $listname =~ s/\s+\Z//;
    return wantarray ? () : 0 unless $listname;

    # Check the number of the MIME parts of this message.  Any mailman
    # moderation message must consist of 3 MIME parts.
    return wantarray ? () : 0 unless $message->parts == 3;

    # Extract the target part.
    my( undef, $target, $confirm ) = $message->parts;
    return wantarray ? () : 0 unless $target->mime_type eq 'message/rfc822';
    $target = $target->parts(0);

    # Extract the confirmation part.
    return wantarray ? () : 0 unless $confirm->mime_type eq 'message/rfc822';
    $confirm = $confirm->parts(0);

    # Check the subject of the confirmation part.  Any mailman
    # moderation message must have has the subject such as "confirm <id>".
    return wantarray ? () : 0 unless $confirm->head->get('subject') =~ m/\Aconfirm [a-zA-Z0-9]+\r?\n?\Z/;
    ( $listname, $target, $confirm );
}

sub open_template {
    my( %option ) = @_;
    push( @_, filter => \&utf8_template_filter ) unless $option{filter};
    push( @_, default_escape => 'HTML' ) unless $option{default_escape};
    unless( $option{path} ){
	my $curdir = &dirname( &abs_path( $ENV{SCRIPT_FILENAME} || $PROGRAM_NAME ) );
	push( @_, path => [$curdir] );
    }
    HTML::Template->new( @_ );
}

sub utf8_template_filter {
    my $ref = shift;
    $$ref = &decode_utf8( $$ref );
}

sub decode_header {
    my( $raw ) = @_;
    join( '', map( $_->[1] ? &decode( $_->[1], $_->[0] ) : $_->[0], &decode_mimewords( $raw ) ) );
}

sub extract_address {
    my( $head ) = @_;
    for my $x ( Mail::Address->parse( $head ) ){
	return $x->address;
    }
    $head;
}

sub check_captcha {
    my( $cgi, $listname ) = @_;
    my $secret = &param_secretkey($listname);
    return 1 unless $secret;
    my $ans = $cgi->param('g-recaptcha-response');
    return 0 unless $ans;
    my $ua = LWP::UserAgent->new();
    my $res = $ua->post( GOOGLEURL,
			 { response => $ans,
			   remoteip => $ENV{REMOTE_ADDR},
			   secret => $secret } );
    if( $res->is_success ){
	print STDERR $res->decoded_content() if &param_debug();
	my $x = &decode_json( $res->decoded_content() );
	return 1 if $x->{success};
    }
    0;
}

sub param_debug {
    &param('debug');
}

sub param_smtpserver {
    &param('smtpserver');
}

sub param_spooldir {
    &param('spooldir');
}

sub param_expire {
    &param('expire');
}

sub param_password {
    &param('password', $_[0]);
}

sub param_login {
    &param('login', $_[0]);
}

sub param_sitekey {
    &param('sitekey', $_[0]);
}

sub param_secretkey {
    &param('secretkey', $_[0]);
}

sub param_notifypat {
    &param('notifypat', $_[0]);
}

sub param_notifybcc {
    &param('notifybcc', $_[0]);
}

sub param {
    my $key = shift;
    my $listname = shift;
    if( @_ ){
	$CONFIG->{$listname || 'default'}->{$key} = \@_;
    } else {
	my $v;
	if( exists $CONFIG->{$listname}->{$key} ) {
	    $v = $CONFIG->{$listname}->{$key};
	} else {
	    $v = $CONFIG->{'default'}->{$key};
	}
	if( $v ){
	    if ( @{$v} == 1 ) {
		$v->[0];
	    } elsif ( @{$v} ) {
		$v;
	    }
	} else {
	    undef;
	}
    }
}

sub read_config {
    state $mtime = 0;
    if( ( ! $CONFIG ) or ( -f CONFIGFILE and stat(CONFIGFILE)->mtime > $mtime ) ){
	my $parser = Config::Simple->new( syntax => 'ini' );
	$CONFIG = $parser->read( CONFIGFILE );
	unless( &param('smtpserver') ){
	    &param('smtpserver', undef, 'localhost');
	}
	unless( &param('spooldir') ){
	    &param('spooldir', undef, &abs_path( &catfile( &dirname($ENV{'SCRIPT_FILENAME'} || $PROGRAM_NAME), 'spool' ) ) );
	}
	unless( defined &param('expire') ){
	    &param('expire', undef, 60 * 60 * 24 * 30);
	}
    }
}

=head1 AUTHOR

TSUCHIYA Masatoshi <tsuchm@gmail.com>

=head1 COPYRIGHT

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
